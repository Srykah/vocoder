<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <title>Vocodeur de phase</title>
		<link rel="stylesheet" type="text/css" href="static/style.css">
</head>
<body>
		<h1>Enregistrez votre voix pour la transformer&nbsp;!</h1>
		
		<h2>Mode d'emploi</h2>
		
		<p>
			Cliquez sur le bouton d'enregistrement ci-dessous pour commencer √† enregistrer votre voix. Une fois que vous √™tes satisfaits, cliquez sur le bouton stop. Ensuite, Choisissez une option de conversion et le ratio √† appliquer dans le menu qui vient d'appara√Ætre, cliquez sur convertir et voil√†&nbsp;! Vous pouvez t√©l√©charger votre voix modifi√©e&nbsp;!
		</p>
		
    <button id="recordButton">üî¥ Enregistrer</button>
    <button id="stopButton" style="display:none;">‚èπ Arr√™ter l'enregistrement</button>
    <button id="playButton" style="display:none;">üï™ Jouer l'enregistrement</button>
		<button id="dismissButton" style="display:none;">‚ùå Supprimer l'enregistrement</button>
    
		<form id="menuForm" style="display:none;">
			<input id="invert" type="radio" name="method" value="invert" checked>Inverser</input> <br/>
			<input id="ts_nat" type="radio" name="method" value="ts_nat">√âtirement temporel (m√©thode na√Øve)</input> <br/>
			<input id="ps_nat" type="radio" name="method" value="ps_nat">Changement d'√©chelle de fr√©quence (m√©thode na√Øve)</input> <br/>
			<input id="ts_voc" type="radio" name="method" value="ts_voc">√âtirement temporel (vocodeur)</input> <br/>
			<input id="ps_voc" type="radio" name="method" value="ps_voc">Changement d'√©chelle de fr√©quence (vocodeur)</input> <br/>
			<input id="ts_nm" type="radio" name="method" value="ts_nm">√âtirement temporel avec la nouvelle m√©thode</input> <br/>
			<input id="ps_nm" type="radio" name="method" value="ps_nm">Changement d'√©chelle de fr√©quence avec la nouvelle m√©thode</input> <br/>
			<label for="ratio">Ratio :</label>
			<input id="ratio" type="number" value="2.0" step="0.1" min="0.1" max="10"/>
		</form>
		
		<button id="convertButton" style="display:none;">üéõ Convertir</button>
		<p id="waitingMessage" style="display:none">En attente de conversion...</p>
		<button id="downloadButton" style="display:none;">üíæ T√©l√©charger</button>
		
		<h2>D√©veloppement des m√©thodes</h2>
		
		<h3>G√©n√©ralit√©s</h3>
		
		<h4>Vocodeur</h4>
		<p>
		Le vocodeur de phase est un vocodeur particulier qui utilise les phases des signaux √† transformer afin d'obtenir les changements fr√©quentiels ou temporels voulus. Le vocodeur de phase utilise la m√©thode de l'analyse/synth√®se : on analyse le signal d'entr√©e en suivant un mod√®le suivant certains param√®tres, puis on le resynth√©tise en changeants certians param√®tres du mod√®le. Ici les signaux sont modelis√©s comme une somme de suinuso√Ødes et les param√®tres sont les fr√©quences et les amplitudes au cours du temps de chaque fr√©quence.
		</p>
		<p>
		Les deux applications majeures du vocodeur de phase sont le changement de fr√©quence d'un signal de parole sans changer l'axe des temps (pitch transposition) et changer l'axe des temps sans changer la fr√©quence, donc la hauteur de la voix (time scaling).
		Pour cela, nous allons commencer par pr√©senter les outils que nous allons utiliser tout le long de ce projet.
		</p>
		<h4>Transform√©e de Fourier √† court terme</h4>
		<p>
		Nous avons en entr√©e un signal num√©rique repr√©sentant le signal de voix, pr√©sent√© sous la forme d'une liste d'amplitude. La fr√©quence d'√©chantillonnage de ce signal est souvent prise f0 = 44100 Hz (les signaux audibles les plus aigues sont √† 20000 Hz, donc cette fr√©quence permet de respecter le crit√®re de Shanon).
		</p>
		<p>
		Nous allons utiliser un outil math√©matique d√©nomm√© la Transform√©e de Fourier √† Court Terme (TFCT, ou short-time Fourier transform, STFT). La diff√©rence avec la transform√©e de Fourier habituelle est que cet op√©rateur math√©matique peut √™tre applique√© √† un signal temporel ayant sa fr√©quence qui varie. 
		Cet op√©rateur consiste √† appliquer la Transform√©e de Fourier sur une fenetre fini du signal d'entr√©e, puis de d√©caler, refaire une transform√©e et ainsi de suite. On obtient ensuite un tableau de dimension (N x M), avec N le nombre de fr√©quence dans les FFT et M le  nombre de FFT, sachant que le nombre de FFT multipli√© par le temps entre deux FFT correspond au temps totale du signal.
		</p>
		<p>
		Si on trace la matrice des modules de la STFT, on obtient un tableau ressemblant au suivant (c'est un spectrogramme) <img src = "static/spectrogramme.png"></img>
		</p>
		<p>
		On a donc en abscisse le temps et en ordonn√©e les fr√©quences. 
		Pour obtenir un son √† partir d'une STFT, il suffit d'appliquer la fonction ISTFT (inverse de la STFT). 
		On commence d√©j√† √† comprendre ce qu'il faudra faire afin de pouvoir appliquer les deux fonctions annonc√©e dans l'introduction.
		</p>
		<h4>Python</h4>
		<p>
		Nous avons travaill√© sous python, et donc nous avons utilis√© la biblioth√®que scipy.signal qui permet d'effectuer facilement des stft ainsi que des istft. Encore avec scipy, nopus avons utilis√© la biblioth√®que scipy.io.wavfile pour g√©rer l'entr√© et la sortie de son sous le format .wav.
		</p>
		<h3>Diff√©rentes m√©thodes</h3>
		
		<h4>√âtirement temporel na√Øf</h4>
		<p>
		Pour jouer un signal plus lentement, on peut penser qu'il suffirait de le jouer en consid√©rant qu'il a une fr√©quence d'√©chantillonnage plus petite.
		Il existe cependant un probl√®me : Si on appelle "composante de fr√©quence n" la ligne n de la STFT du signal d'entr√©e, alors la fr√©quence r√©elle associ√©e √† ce signal s'exprime comme la diff√©rence de phase entre deux points d'abscisses successives divis√© par la dur√©e entre ces deux abscisse. En jouant juste le fichier plus lentement, on obtient un changement de fr√©quence. En effet, en doublant la dur√©e entre deux fft successives, on divise par 2 la fr√©quence. C'est bien ce qu'on remarque quand on fait l'essai.   
		</p>
		
		<h4>Changement d'√©chelle de fr√©quence na√Øve</h4>
		<p>
		De mani√®re ressemblante, la m√©thode pr√©c√©dente nous permet de modifier la fr√©quence, mais on a malheureusement un changement d'√©chelle temporelle en m√™me temps, or ce n'est pas ce que l'on veut.
		</p>
		
		<h4>√âtirement temporel avec vocodeur de phase</h4>
		<p>
		Une approche simple pour √©tirer un signal tout en gardant les fr√©quences constantes est de passer par le spectrogramme du signal, d'allonger celui-ci du facteur demand√©, et de reconstituer le signal temporel. Cette technique fonctionne bien pour l'amplitude de chaque fr√©quence, cependant il faut aussi prendre en compte la phase, qui est d√©cal√©e et rend le signal inaudible.
		Le vocodeur de phase modifie donc la phase de la stft afin que lors de la reconstitution les recouvrements des fft successives s'additionnent bien avec une phase coh√©rente.
		Comme sur le spectrogramme le temps est sur l'axe horizontal, et qu'on corrige le d√©calage de phase dans le temps, on appelle cette correction de phase le maintien de la coh√©rence horizontale du signal.
		</p>
		<p>
		Cependant, cet algorithme ne prend pas en compte la coh√©rence verticale, ou coh√©rence de phase entre les fr√©quences adjacentes ; en effet, quand un signal passe d'une composante √† une autre, un d√©calage de phase peut survenir, ce qui rend le signal global m√©tallique et donne un effet d'√©cho.
		On remarque apr√®s calcul que ce probl√®me ne survient pas pour des ratios entiers.
		L'algorithme suivant cherche √† corriger ce probl√®me.
		</p>
		
		<h4>Changement d'√©chelle de fr√©quence avec vocodeur de phase</h4>
		<p>
		Pour avoir un changement d'echelle de fr√©quence sans changement d'√©chelle temporelle, on va utiliser astucieusement les m√©thodes pr√©c√©dentes. C'est √† dire qu'on va changer la fr√©quence de mani√®re na√Øve, puis on va utiliser le fait qu'on sait modifier l'√©chelle temporelle sans toucher √† l'√©chelle fr√©quentielle pour ramener le signal sur la bonne dur√©e. On obtient ainsi un changement de fr√©quence sans changement de temps -> pitch transposition	
		</p>
		
		<h3>Nouvelle m√©thode</h3>
		<p>
		La m√©thode effectu√©e precedemment nous donne des r√©sultats satisfaisants, mais il y a des probl√®mes dans certains cas particuliers (√©voqu√©s plus haut).
		Nous avons alors mit en place une autre m√©thode, qui prend en compte les d√©riv√©s partielles temporelles et fr√©quentielles pour assurer la coh√©rence dans ces deux espaces.
		Les d√©riv√©s sont calcul√©es de mani√®res discr√®tes en utilisant la m√©thode des diff√©rences finies. C'est l'√©quivalent des d√©riv√©s mais en discret. 
		</p>
		<p>
		Id√©e de m√©thode : On modifie les phases de mani√®re ordonn√©e. On le fait frame par frame, et on retient √† chaque fois les phases de la frame pr√©c√©dente ainsi que les d√©riv√©s temporelles de la frame pr√©c√©dente. On commence par choisir la fr√©quence pour laquelle l'amplitude √©tait la plus grande √† la frame derni√®re, et propage la phase en utilisant la d√©riv√©e temporelle (horizontalement), c'est √† dire qu'on compl√®te de mani√®re lin√©aire. Ensuite, et c'est ce qui fait la sp√©cificit√© de cette m√©thode, on propage aussi la phase de mani√®re verticale si l'amplitude des point adjacents n'est pas n√©gligeable. On a ainsi une coh√©rence verticale et horizontale, ce qui amoindrit les art√©facts.
		</p>
		<h3>CONCLUSION</h3>
		<p>
		Travailler num√©riquement sur des signaux sonores demande une compr√©hension particuli√®re du lien temps/fr√©quence. Cela permet de comprendre certains ph√©nom√®nes, tels que la baisse de fr√©quence li√©e √† l'allongement du temps. Cette compr√©hension permet aussi de r√©gler ces probl√®mes, grace aux diff√©rentes m√©thodes que nous avons impl√©ment√©. Nos r√©sultats sonnent cependant encore m√©talliques pour les changements de fr√©quence et de dur√©e non-entiers. De plus, les temps de calculs sont assez longs, rendant impossible l'utilisation algorithmes en temps r√©el.
		</p>
		
		<h4>Documents utiles</h4>
		<p>
		Nous mettons en lien les documents qui nous ont permis de comprendre le sujet, dans lesquels apparaissent les programmes complets que nous avons mit en oeuvre.
		<ol><li><a href = "static/PhaseVocoderTutorial.pdf" download>Explication simple du principe</a></li>
		<li><a href = "static/laroche_dolson.pdf" download>Explication algorithme vocodeur</a></li>
		<li><a href = "static/ltfatnote050.pdf" download>Explication nouvelle m√©thode</a></li>
		</ol>
		 
		</p>
		<p>
		Nous mettons aussi <a href = "static/script.py" download>nos programmes</a>, si vous voulez les utiliser comme base pour d'autres travaux. 
		</p>
		
		<h2>MERCI !</h2>
		
		<h4> Travail effectu√© par Thomas B√âCAVIN et Galaad LECONTE dans le cadre du projet de 1ere ann√©e du cursus Sup√©lec de l'√©cole CentraleSup√©lec, sous la supervision de Gilles CHARDON</h4>
		
		<script src="static/global.js"></script>
		<script src="static/record.js"></script>
		<script src="static/stop.js"></script>
		<script src="static/play.js"></script>
		<script src="static/dismiss.js"></script>
		<script src="static/convert.js"></script>
		<script src="static/download.js"></script>
		
		<script src="static/init.js"></script>
</body>
</html>